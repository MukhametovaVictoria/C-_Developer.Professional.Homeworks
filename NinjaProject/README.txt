Задание:

0. Придумать и создать 3-4 класса, которые как минимум дважды наследуются и написать краткое описание текстом.

1. Создать свой дженерик интерфейс IMyCloneable для реализации шаблона "Прототип".

2. Сделать возможность клонирования объекта для каждого из этих классов, используя вызовы родительских конструкторов.

3. Составить тесты или написать программу для демонстрации функции клонирования.

4. Добавить к каждому классу реализацию стандартного интерфейса ICloneable и реализовать его функционал через уже созданные методы.

5. Написать вывод: какие преимущества и недостатки у каждого из интерфейсов: IMyCloneable и ICloneable.

Решение:

0. Созданы классы персонажей, которые находятся в папках Entities -> Konoha, Suna, Kiri. Наследуются от BaseNinjaPrototype, который наследуется от IMyCloneable<BaseNinjaPrototype> и ICloneable.

1. Создан свой дженерик интерфейс IMyCloneable, находится в папке Entities -> Interfaces. Реализация шаблона "Прототип" в абстрактном классе BaseNinjaPrototype.

2. В классах из пункта 0 реализована возможность клонирования объектов, используя вызов родительского конструктора.

3. Демонстрация в классе Program. Создается указанное пользователем количество клонов, затем предлагается одному поменять свойство Appearance, затем выводятся характеристики всех клонов.

4. К каждому классу была добавлена реализация стандартного интерфейса ICloneable, в классе Program предлагается выбор, как именно создавать клонов.

5. Выводы:
IClonable: Нет привязки к конкретному типу возвращаемого значения. Этот интерфейс не указывает, должна ли копия быть глубокой или поверхностой. Также в интерфейсе есть метод MemberwiseClone(), который возвращает копию объекта, без необходимости передачи параметров и он реализует поверхностное (неглубокое) копирование. Иногда оно бывает нужно, когда в объекте есть только свойства примитивного типа и не требуется глубокого копирования, тогда нет необходимости писать свою реализацию. 
IMyCloneable: требует четкого указания какой класс будет клонирован. Писать реализацию нужно обязательно. Можно навесить ограничения. При изменении полей, нуобходимо будет переписать функцию копирования (хотя при глубоком копировании ICloneable тоже).
В целом считаю, что свой дженерик при глубоком копировании более надежен, т.к. мы получим тот класс, который ожидаем. В то же время, если глубокое копирование не требуется, то проще использовать ICloneable.